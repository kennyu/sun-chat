import React, { createContext, useCallback, useContext, useEffect, useMemo, useRef, useState } from "react";import { Platform } from "react-native";import { useAuth } from "@clerk/clerk-expo";import { useMutation } from "convex/react";import { api } from "../convex/_generated/api";type Room = {  _id: string;  name: string;  isGroup?: boolean;};type Message = {  _id: string; // server id or local- prefixed id  roomId: string;  senderId: string;  kind: string; // "text" | "image"  text?: string;  imageUrl?: string;  createdAt: number;  pending?: boolean;};type OutboxItem = {  id: string; // uuid  type: "message.send";  payload: any;};type LocalStoreContextValue = {  rooms: Room[];  messagesByRoomId: Record<string, Message[]>;  reloadRoomsFromDisk: () => Promise<void>;  reloadMessagesForRoomFromDisk: (roomId: string) => Promise<void>;  saveRoomsFromServer: (rooms: Room[]) => Promise<void>;  saveMessagesFromServer: (roomId: string, messages: Message[]) => Promise<void>;  useLocalMessages: (roomId: string | undefined) => Message[];  sendMessage: (args: { roomId: string; kind: string; text?: string; imageUrl?: string }) => Promise<string>; // returns localId  markMessageDelivered: (localId: string, serverId: string) => Promise<void>;  drainOutbox: () => Promise<void>;};const LocalStoreContext = createContext<LocalStoreContextValue | null>(null);// On web, avoid importing expo-sqlite to prevent wasm bundling issuesconst isWeb = Platform.OS === "web";let SQLite: any = null;if (!isWeb) {  // eslint-disable-next-line @typescript-eslint/no-var-requires  SQLite = require("expo-sqlite");}function openDbSafe() {  try {    if (isWeb) return null as any;    // @ts-ignore - older API fallback name    return (SQLite as any).openDatabase?.("sunchat.db") ?? (SQLite as any).openDatabaseSync?.("sunchat.db");  } catch {    return null as any;  }}const db = openDbSafe();async function ensureTables() {  if (!db) return;  await new Promise<void>((resolve) => {    db.transaction((tx: any) => {      tx.executeSql(        "CREATE TABLE IF NOT EXISTS rooms (id TEXT PRIMARY KEY NOT NULL, json TEXT NOT NULL);"      );      tx.executeSql(        "CREATE TABLE IF NOT EXISTS messages (id TEXT PRIMARY KEY NOT NULL, roomId TEXT NOT NULL, createdAt INTEGER NOT NULL, json TEXT NOT NULL);"      );      tx.executeSql(        "CREATE TABLE IF NOT EXISTS outbox (id TEXT PRIMARY KEY NOT NULL, type TEXT NOT NULL, payload TEXT NOT NULL);"      );    }, undefined, () => resolve());  });}function execSql<T = any>(sql: string, params: any[] = []): Promise<{ rows: T[] }>{  if (!db) return Promise.resolve({ rows: [] as T[] });  return new Promise((resolve, reject) => {    db.readTransaction((tx: any) => {      tx.executeSql(        sql,        params,        (_: any, result: any) => {          const rows: T[] = [];          const len = result.rows.length;          for (let i = 0; i < len; i++) rows.push(result.rows.item(i));          resolve({ rows });        },        (_: any, err: any) => {          reject(err);          return true;        }      );    });  });}function runSql(sql: string, params: any[] = []): Promise<void> {  if (!db) return Promise.resolve();  return new Promise((resolve, reject) => {    db.transaction((tx: any) => {      tx.executeSql(sql, params);    }, reject, resolve);  });}// localStorage helpers for web fallbackfunction lsGet<T>(key: string, fallback: T): T {  try {    const raw = globalThis.localStorage?.getItem(key);    if (!raw) return fallback;    return JSON.parse(raw) as T;  } catch {    return fallback;  }}function lsSet<T>(key: string, value: T): void {  try {    globalThis.localStorage?.setItem(key, JSON.stringify(value));  } catch {}}export function LocalStoreProvider({ children }: { children: React.ReactNode }) {  const { userId } = useAuth();  const sendMessageMutation = useMutation(api.messages.send);  const [rooms, setRooms] = useState<Room[]>([]);  const [messagesByRoomId, setMessagesByRoomId] = useState<Record<string, Message[]>>({});  const drainingRef = useRef(false);  useEffect(() => {    ensureTables().then(() => {      reloadRoomsFromDisk();    });  }, []);  const reloadRoomsFromDisk = useCallback(async () => {    if (!db) {      const list = lsGet<Room[]>("rooms", []);      setRooms(list);      return;    }    const { rows } = await execSql<{ json: string }>("SELECT json FROM rooms");    const parsed = rows.map((r) => JSON.parse(r.json) as Room);    setRooms(parsed);  }, []);  const reloadMessagesForRoomFromDisk = useCallback(async (roomId: string) => {    if (!db) {      const key = `messages:${roomId}`;      const list = lsGet<Message[]>(key, []);      setMessagesByRoomId((prev) => ({ ...prev, [roomId]: list }));      return;    }    const { rows } = await execSql<{ json: string }>(      "SELECT json FROM messages WHERE roomId = ? ORDER BY createdAt ASC",      [roomId]    );    const parsed = rows.map((r) => JSON.parse(r.json) as Message);    setMessagesByRoomId((prev) => ({ ...prev, [roomId]: parsed }));  }, []);  const saveRoomsFromServer = useCallback(async (incoming: Room[]) => {    if (!incoming || incoming.length === 0) return;    if (!db) {      // overwrite snapshot for simplicity      lsSet<Room[]>("rooms", incoming);      setRooms(incoming);      return;    }    // upsert    await runSql("BEGIN TRANSACTION");    for (const room of incoming) {      await runSql(        "INSERT OR REPLACE INTO rooms (id, json) VALUES (?, ?)",        [room._id, JSON.stringify(room)]      );    }    await runSql("COMMIT");    await reloadRoomsFromDisk();  }, [reloadRoomsFromDisk]);  const saveMessagesFromServer = useCallback(async (roomId: string, incoming: Message[]) => {    if (!roomId || !incoming) return;    if (!db) {      const key = `messages:${roomId}`;      const existing = lsGet<Message[]>(key, []);      const map = new Map<string, Message>();      for (const m of existing) map.set(m._id, m);      for (const m of incoming) map.set(m._id, { ...m, pending: false });      const merged = Array.from(map.values()).sort((a, b) => a.createdAt - b.createdAt);      lsSet<Message[]>(key, merged);      setMessagesByRoomId((prev) => ({ ...prev, [roomId]: merged }));      return;    }    await runSql("BEGIN TRANSACTION");    for (const m of incoming) {      await runSql(        "INSERT OR REPLACE INTO messages (id, roomId, createdAt, json) VALUES (?, ?, ?, ?)",        [m._id, m.roomId, m.createdAt, JSON.stringify({ ...m, pending: false })]      );    }    await runSql("COMMIT");    await reloadMessagesForRoomFromDisk(roomId);  }, [reloadMessagesForRoomFromDisk]);  const useLocalMessages = useCallback((roomId: string | undefined) => {    const [local, setLocal] = useState<Message[]>([]);    useEffect(() => {      if (!roomId) return;      // subscribe to provider state and perform initial load from disk if needed      if (!messagesByRoomId[roomId]) {        reloadMessagesForRoomFromDisk(roomId);      }      setLocal(messagesByRoomId[roomId] ?? []);    }, [roomId, messagesByRoomId]);    return local;  }, [messagesByRoomId, reloadMessagesForRoomFromDisk]);  const sendMessage = useCallback(async (args: { roomId: string; kind: string; text?: string; imageUrl?: string }) => {    if (!userId) throw new Error("Unauthenticated");    const localId = `local_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;    const msg: Message = {      _id: localId,      roomId: args.roomId,      senderId: userId,      kind: args.kind,      text: args.text,      imageUrl: args.imageUrl,      createdAt: Date.now(),      pending: true,    };    if (!db) {      const key = `messages:${msg.roomId}`;      const list = lsGet<Message[]>(key, []);      list.push(msg);      list.sort((a, b) => a.createdAt - b.createdAt);      lsSet<Message[]>(key, list);      setMessagesByRoomId((prev) => ({ ...prev, [msg.roomId]: list }));      const outbox = lsGet<OutboxItem[]>("outbox", []);      outbox.push({ id: `ob_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`, type: "message.send", payload: { localId: localId, roomId: args.roomId, kind: args.kind, text: args.text, imageUrl: args.imageUrl } });      lsSet("outbox", outbox);    } else {      await runSql(        "INSERT OR REPLACE INTO messages (id, roomId, createdAt, json) VALUES (?, ?, ?, ?)",        [msg._id, msg.roomId, msg.createdAt, JSON.stringify(msg)]      );      setMessagesByRoomId((prev) => {        const list = prev[msg.roomId] ? [...prev[msg.roomId]] : [];        list.push(msg);        return { ...prev, [msg.roomId]: list };      });      const outboxId = `ob_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;      const payload = { localId: localId, roomId: args.roomId, kind: args.kind, text: args.text, imageUrl: args.imageUrl };      await runSql("INSERT OR REPLACE INTO outbox (id, type, payload) VALUES (?, ?, ?)", [outboxId, "message.send", JSON.stringify(payload)]);    }    return localId;  }, [userId]);  const markMessageDelivered = useCallback(async (localId: string, serverId: string) => {    if (!db) {      // Find the room list containing this localId      const keys = Object.keys(messagesByRoomId);      for (const roomId of keys) {        const list = lsGet<Message[]>(`messages:${roomId}`, []);        const idx = list.findIndex((m) => m._id === localId);        if (idx >= 0) {          const updated: Message = { ...list[idx], _id: serverId, pending: false };          list.splice(idx, 1, updated);          lsSet<Message[]>(`messages:${roomId}`, list);          setMessagesByRoomId((prev) => ({ ...prev, [roomId]: list }));          const outbox = lsGet<OutboxItem[]>("outbox", []);          const remaining = outbox.filter((o) => !(o.type === "message.send" && o.payload?.localId === localId));          lsSet("outbox", remaining);          break;        }      }      return;    }    // Load the local message, replace id and pending flag    const { rows: msgRows } = await execSql<{ json: string }>("SELECT json FROM messages WHERE id = ?", [localId]);    if (msgRows.length === 0) return;    const localMsg = JSON.parse(msgRows[0].json) as Message;    const updated: Message = { ...localMsg, _id: serverId as any, pending: false };    await runSql("DELETE FROM messages WHERE id = ?", [localId]);    await runSql(      "INSERT OR REPLACE INTO messages (id, roomId, createdAt, json) VALUES (?, ?, ?, ?)",      [updated._id, updated.roomId, updated.createdAt, JSON.stringify(updated)]    );    // Remove any matching outbox rows that reference this localId    await runSql("DELETE FROM outbox WHERE type = ? AND payload LIKE ?", ["message.send", `%"localId":"${localId}"%`]);    setMessagesByRoomId((prev) => {      const list = (prev[updated.roomId] ?? []).filter((m) => m._id !== localId);      list.push(updated);      list.sort((a, b) => a.createdAt - b.createdAt);      return { ...prev, [updated.roomId]: list };    });  }, []);  const drainOutbox = useCallback(async () => {    if (drainingRef.current) return;    drainingRef.current = true;    try {      if (!db) {        const outbox = lsGet<OutboxItem[]>("outbox", []);        const remaining: OutboxItem[] = [];        for (const item of outbox) {          if (item.type === "message.send") {            try {              const serverId = await sendMessageMutation({ roomId: item.payload.roomId, kind: item.payload.kind, text: item.payload.text, imageUrl: item.payload.imageUrl });              await markMessageDelivered(item.payload.localId, serverId as any);            } catch {              remaining.push(item);              break;            }          } else {            remaining.push(item);          }        }        lsSet<OutboxItem[]>("outbox", remaining);      } else {        const { rows } = await execSql<{ id: string; type: string; payload: string }>("SELECT id, type, payload FROM outbox ORDER BY id ASC");        for (const row of rows) {          const payload = JSON.parse(row.payload);          if (row.type === "message.send") {            try {              const serverId = await sendMessageMutation({ roomId: payload.roomId, kind: payload.kind, text: payload.text, imageUrl: payload.imageUrl });              // Update local message: replace localId with server id and mark not pending              const { rows: msgRows } = await execSql<{ json: string }>("SELECT json FROM messages WHERE id = ?", [payload.localId]);              if (msgRows.length > 0) {                const localMsg = JSON.parse(msgRows[0].json) as Message;                const updated: Message = { ...localMsg, _id: serverId as any, pending: false };                await runSql("DELETE FROM messages WHERE id = ?", [payload.localId]);                await runSql(                  "INSERT OR REPLACE INTO messages (id, roomId, createdAt, json) VALUES (?, ?, ?, ?)",                  [updated._id, updated.roomId, updated.createdAt, JSON.stringify(updated)]                );                setMessagesByRoomId((prev) => {                  const list = (prev[updated.roomId] ?? []).filter((m) => m._id !== payload.localId);                  list.push(updated);                  list.sort((a, b) => a.createdAt - b.createdAt);                  return { ...prev, [updated.roomId]: list };                });              }              await runSql("DELETE FROM outbox WHERE id = ?", [row.id]);            } catch {              // stop draining on first failure (likely offline)              break;            }          }        }      }    } finally {      drainingRef.current = false;    }  }, [sendMessageMutation]);  const value: LocalStoreContextValue = useMemo(() => ({    rooms,    messagesByRoomId,    reloadRoomsFromDisk,    reloadMessagesForRoomFromDisk,    saveRoomsFromServer,    saveMessagesFromServer,    useLocalMessages,    sendMessage,    markMessageDelivered,    drainOutbox,  }), [rooms, messagesByRoomId, reloadRoomsFromDisk, reloadMessagesForRoomFromDisk, saveRoomsFromServer, saveMessagesFromServer, useLocalMessages, sendMessage, markMessageDelivered, drainOutbox]);  return <LocalStoreContext.Provider value={value}>{children}</LocalStoreContext.Provider>;}export function useLocalStore() {  const ctx = useContext(LocalStoreContext);  if (!ctx) throw new Error("useLocalStore must be used within LocalStoreProvider");  return ctx;}